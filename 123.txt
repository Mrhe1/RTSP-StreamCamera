

以下是使用Camera2 API实现三个独立配置流的完整方案，包含帧率、分辨率和防抖的独立配置：

### 一、流配置数据结构设计
```java
// 流类型枚举
enum StreamType {
    PREVIEW,    // 预览流
    STREAMING,  // 推流
    RECORDING   // 录制流
}

// 流配置类
class StreamConfig {
    Size resolution;
    int fps;
    StabilizationMode stabilization;
    ImageFormat format;

    StreamConfig(Size res, int fps, StabilizationMode stab, ImageFormat fmt) {
        this.resolution = res;
        this.fps = fps;
        this.stabilization = stab;
        this.format = fmt;
    }
}

// 全局配置存储
Map<StreamType, StreamConfig> streamConfigs = new HashMap<>();
```

### 二、多流配置实现
```java
// 初始化配置示例
void initConfigs() {
    streamConfigs.put(StreamType.PREVIEW,
        new StreamConfig(new Size(1920, 1080), 30, StabilizationMode.HYBRID, ImageFormat.JPEG));

    streamConfigs.put(StreamType.STREAMING,
        new StreamConfig(new Size(1280, 720), 25, StabilizationMode.EIS_ONLY, ImageFormat.YUV_420_888));

    streamConfigs.put(StreamType.RECORDING,
        new StreamConfig(new Size(3840, 2160), 30, StabilizationMode.OIS_ONLY, ImageFormat.YUV_420_888));
}
```

### 三、设备支持性检查
```java
boolean checkStreamSupport(CameraCharacteristics characteristics) {
    StreamConfigurationMap map = characteristics.get(
        CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);

    // 检查最大流数量
    Integer maxStreams = characteristics.get(CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_STREAMS);
    if (maxStreams == null || maxStreams < 3) {
        Timber.e("设备最多支持%d个输出流", maxStreams);
        return false;
    }

    // 检查每个流的配置
    for (Map.Entry<StreamType, StreamConfig> entry : streamConfigs.entrySet()) {
        StreamConfig config = entry.getValue();
        Size[] supportedSizes = map.getOutputSizes(config.format);

        if (!Arrays.stream(supportedSizes).anyMatch(s ->
            s.getWidth() == config.resolution.getWidth() &&
            s.getHeight() == config.resolution.getHeight())) {

            Timber.e("%s流分辨率%d×%d不支持",
                entry.getKey().name(),
                config.resolution.getWidth(),
                config.resolution.getHeight());
            return false;
        }
    }
    return true;
}
```

### 四、帧率独立配置方案
```java
void configureFps(CaptureRequest.Builder builder, StreamType type) {
    StreamConfig config = streamConfigs.get(type);
    Range<Integer>[] availableRanges = characteristics.get(
        CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES);

    // 寻找最佳帧率范围
    Range<Integer> bestRange = null;
    for (Range<Integer> range : availableRanges) {
        if (range.getUpper() >= config.fps && range.getLower() <= config.fps) {
            if (bestRange == null || range.getUpper() > bestRange.getUpper()) {
                bestRange = range;
            }
        }
    }

    if (bestRange != null) {
        builder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, bestRange);
        Timber.i("%s流帧率设置: %d-%d FPS",
            type.name(), bestRange.getLower(), bestRange.getUpper());
    } else {
        Timber.w("无法满足%s流%d FPS要求", type.name(), config.fps);
    }
}
```

### 五、防抖独立配置方案
```java
void configureStabilization(CaptureRequest.Builder builder, StreamType type) {
    StabilizationMode mode = streamConfigs.get(type).stabilization;

    switch (mode) {
        case OIS_ONLY:
            builder.set(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE,
                CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE_ON);
            builder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE,
                CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_OFF);
            break;

        case EIS_ONLY:
            builder.set(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE,
                CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE_OFF);
            builder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE,
                CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_ON);
            break;

        case HYBRID:
            builder.set(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE,
                CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE_ON);
            builder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE,
                CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_ON);
            break;

        default:
            builder.set(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE,
                CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE_OFF);
            builder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE,
                CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_OFF);
    }

    Timber.i("%s流防抖模式: %s", type.name(), mode.name());
}
```

### 六、多流会话配置
```java
void createMultiStreamSession(CameraDevice device) {
    List<Surface> surfaces = new ArrayList<>();

    // 预览Surface
    Surface previewSurface = previewView.getSurface();
    surfaces.add(previewSurface);

    // 推流ImageReader
    ImageReader streamingReader = ImageReader.newInstance(
        streamConfigs.get(StreamType.STREAMING).resolution.getWidth(),
        streamConfigs.get(StreamType.STREAMING).resolution.getHeight(),
        streamConfigs.get(StreamType.STREAMING).format,
        3);
    surfaces.add(streamingReader.getSurface());

    // 录制Surface
    Surface recordingSurface = videoRecorder.getInputSurface();
    surfaces.add(recordingSurface);

    device.createCaptureSession(surfaces, new CameraCaptureSession.StateCallback() {
        @Override
        public void onConfigured(@NonNull CameraCaptureSession session) {
            try {
                // 为每个流创建独立Request
                CaptureRequest.Builder previewBuilder = device.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
                CaptureRequest.Builder streamingBuilder = device.createCaptureRequest(CameraDevice.TEMPLATE_RECORD);
                CaptureRequest.Builder recordingBuilder = device.createCaptureRequest(CameraDevice.TEMPLATE_VIDEO_SNAPSHOT);

                // 配置各流参数
                configureStream(previewBuilder, StreamType.PREVIEW);
                configureStream(streamingBuilder, StreamType.STREAMING);
                configureStream(recordingBuilder, StreamType.RECORDING);

                // 提交组合请求
                session.setRepeatingBurst(
                    Arrays.asList(
                        previewBuilder.build(),
                        streamingBuilder.build(),
                        recordingBuilder.build()
                    ), null, cameraHandler);

            } catch (CameraAccessException e) {
                Timber.e(e, "提交组合请求失败");
            }
        }

        @Override
        public void onConfigureFailed(@NonNull CameraCaptureSession session) {
            Timber.e("会话配置失败");
            setState(WorkflowState.ERROR);
            stopCamera();
        }
    }, cameraHandler);
}

private void configureStream(CaptureRequest.Builder builder, StreamType type) {
    // 添加目标Surface
    switch (type) {
        case PREVIEW:
            builder.addTarget(previewSurface);
            break;
        case STREAMING:
            builder.addTarget(streamingReader.getSurface());
            break;
        case RECORDING:
            builder.addTarget(recordingSurface);
            break;
    }

    // 配置独立参数
    configureFps(builder, type);
    configureStabilization(builder, type);

    // 公共参数
    builder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_AUTO);
    builder.set(CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE,
        CaptureRequest.COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY);
}
```

### 七、动态参数调整
```java
void adjustStreamConfig(StreamType type, StreamConfig newConfig) {
    // 检查新配置有效性
    if (!isConfigSupported(newConfig)) {
        Timber.e("%s流新配置不支持", type.name());
        return;
    }

    // 更新配置
    streamConfigs.put(type, newConfig);

    try {
        // 重新配置会话
        CaptureRequest.Builder builder = device.createCaptureRequest(
            getTemplateType(type));

        configureStream(builder, type);
        session.setRepeatingRequest(builder.build(), null, cameraHandler);

    } catch (CameraAccessException e) {
        Timber.e(e, "动态调整%s流配置失败", type.name());
    }
}

private int getTemplateType(StreamType type) {
    switch (type) {
        case PREVIEW: return CameraDevice.TEMPLATE_PREVIEW;
        case STREAMING: return CameraDevice.TEMPLATE_RECORD;
        case RECORDING: return CameraDevice.TEMPLATE_VIDEO_SNAPSHOT;
        default: return CameraDevice.TEMPLATE_PREVIEW;
    }
}
```

### 八、配置兼容性矩阵示例
| 配置项         | 预览流             | 推流               | 录制流               |
|----------------|--------------------|--------------------|----------------------|
| 分辨率         | 1920x1080          | 1280x720           | 3840x2160            |
| 帧率           | 30 FPS             | 25 FPS             | 30 FPS               |
| 防抖模式       | Hybrid(OIS+EIS)    | EIS Only           | OIS Only             |
| 图像格式       | JPEG               | YUV_420_888        | YUV_420_888          |
| 缓冲区数量     | 3                  | 3                  | 3                    |
| 目标Surface    | PreviewView        | ImageReader        | MediaCodec Input     |

### 九、错误处理增强
```java
void handleCameraError(int errorCode) {
    String errorDesc;
    switch (errorCode) {
        case ERROR_CAMERA_IN_USE:
            errorDesc = "摄像头被其他进程占用";
            break;
        case ERROR_MAX_CAMERAS_IN_USE:
            errorDesc = "达到最大摄像头使用数";
            break;
        case ERROR_CAMERA_DEVICE:
            errorDesc = "摄像头硬件故障";
            break;
        case ERROR_CAMERA_DISABLED:
            errorDesc = "摄像头被管理员禁用";
            break;
        case ERROR_CAMERA_SERVICE:
            errorDesc = "摄像头服务异常";
            break;
        default:
            errorDesc = "未知错误";
    }

    Timber.e("摄像头错误[%d]: %s", errorCode, errorDesc);
    setState(WorkflowState.ERROR);
    stopCamera();

    // 通知UI
    runOnUiThread(() -> Toast.makeText(this,
        "摄像头错误: " + errorDesc, Toast.LENGTH_LONG).show());
}
```

### 十、性能优化建议

1. **缓冲区管理**：
```java
// 使用环形缓冲区池
class BufferPool {
    private final Queue<ByteBuffer> pool = new ArrayDeque<>(5);

    synchronized ByteBuffer getBuffer(int size) {
        ByteBuffer buffer = pool.poll();
        if (buffer == null || buffer.capacity() < size) {
            return ByteBuffer.allocateDirect(size);
        }
        buffer.clear();
        return buffer;
    }

    synchronized void returnBuffer(ByteBuffer buffer) {
        if (pool.size() < 5) {
            pool.offer(buffer);
        }
    }
}
```

2. **GPU加速转换**：
```java
// 使用RenderScript实现YUV到RGB的高效转换
private ScriptIntrinsicYuvToRGB yuvToRgbScript;

void initYuvConverter() {
    RenderScript rs = RenderScript.create(this);
    yuvToRgbScript = ScriptIntrinsicYuvToRGB.create(
        rs, Element.U8_4(rs));
}

void convertYuvToRgb(Image yuvImage, Bitmap outputBitmap) {
    Allocation inAlloc = Allocation.createFromYuv(
        rs, yuvImage.getPlanes(),
        yuvImage.getWidth(), yuvImage.getHeight());

    Allocation outAlloc = Allocation.createFromBitmap(rs, outputBitmap);

    yuvToRgbScript.setInput(inAlloc);
    yuvToRgbScript.forEach(outAlloc);
    outAlloc.copyTo(outputBitmap);
}
```

该方案完整实现了三个独立流的配置管理，每个流均可独立设置分辨率、帧率和防抖模式。通过Camera2的灵活配置，可在保证兼容性的前提下实现高性能的多流处理。实际部署时需要根据设备特性进行动态降级适配。

改为共用同一个videocapture，参数ois和帧率等统一设置，而eis和分辨率分别设置